# /etc/nginx/sites-available/zerotrust_proxy

# Define allowed IP ranges (adjust to your network)
geo $allowed_ip {
    default 0;       # Deny by default
    127.0.0.1 1;     # Allow localhost (IPv4)
    ::1       1;     # Allow localhost (IPv6)
    192.168.22.0/24 1; # Example Admin Range
    192.168.23.0/24 1; # Example Analyst Range
    10.10.0.0/16 1;   # Example Guest Range
}

# Upstream definitions for our backend services
upstream flask_session_manager {
    server 127.0.0.1:5000;
}

upstream gradio_ai_scanner {
    # --- *** IMPORTANT: Update this port if Gradio runs elsewhere *** ---
    server 127.0.0.1:5001; # Default Gradio port is usually 7860, update if needed
}

# --- *** NEW: Upstream for the Dashboard App *** ---
upstream corporate_dashboard {
    server 127.0.0.1:5002; # Dashboard app listens on port 5002
}

upstream sast_analyzer {
    server 127.0.0.1:5003; # Dashboard app listens on port 5002
}


# Redirect HTTP to HTTPS (remains the same)
server {
    listen 80;
    server_name localhost your_domain.com; # Replace if applicable
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name localhost your_domain.com; # Replace if applicable

    # TLS Configuration (remains the same)
    ssl_certificate /etc/nginx/ssl/zerotrust_proxy.crt;
    ssl_certificate_key /etc/nginx/ssl/zerotrust_proxy.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    # --- Step 1: Network Layer Security (remains the same) ---
    if ($allowed_ip = 0) {
        return 403;
    }

    # --- Session Initialization Endpoint (remains the same) ---
    # NOTE: Now redirects to /gateway after successful POST
    location = /session/init {
        proxy_pass http://flask_session_manager/session/init;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        # Pass custom headers (remains the same, use with caution)
        proxy_set_header X-Device-MAC $http_x_device_mac;
        proxy_set_header X-Device-Hostname $http_x_device_hostname;
    }

    # --- *** NEW: Gateway Endpoint (served by session manager) *** ---
    # Needs to be accessible AFTER session init redirects here
    location = /gateway {
        # This request should have the session cookie set by the /session/init redirect
        proxy_pass http://flask_session_manager/gateway;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }


    # --- Session Check Endpoint (remains the same) ---
    location = /session/check {
        proxy_pass http://flask_session_manager/session/check;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Device-MAC $http_x_device_mac;
        proxy_set_header X-Device-Hostname $http_x_device_hostname;
    }

    # --- Session Verification Endpoint (Internal - remains the same) ---
    location = /auth/verify {
        internal;
        proxy_pass http://flask_session_manager/session/verify;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
        proxy_set_header X-Original-URI $request_uri; # Crucial for RBAC
        proxy_set_header X-Original-Method $request_method; # Pass method too!
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Device-MAC $http_x_device_mac;
        proxy_set_header X-Device-Hostname $http_x_device_hostname;
    }

    # --- Main Protected Location (Gradio AI Scanner) ---
     location / {
        # Step 1: Authenticate & Authorize via Session Manager
        auth_request /auth/verify;
        auth_request_set $auth_session_id $upstream_http_x_zt_session_id;
        auth_request_set $auth_user_id $upstream_http_x_zt_user_id;
        auth_request_set $auth_user_role $upstream_http_x_zt_user_role;
        auth_request_set $auth_access_level $upstream_http_x_zt_access_level;
        error_page 401 = @handle_unauthorized;
        error_page 403 = @handle_forbidden;
        error_page 503 = @handle_service_unavailable;

        # Step 2: Proxy to AI Scanner App
        proxy_pass http://gradio_ai_scanner;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header X-Auth-Session-ID $auth_session_id;
        proxy_set_header X-Auth-User-ID $auth_user_id;
        proxy_set_header X-Auth-User-Role $auth_user_role;
        proxy_set_header X-Auth-Access-Level $auth_access_level;

        # --- INCREASED TIMEOUTS FOR GRADIO ---
        # Set longer timeouts specifically for the Gradio backend
        # Adjust values as needed (e.g., 300s = 5 minutes)
        proxy_connect_timeout 75s;
        proxy_send_timeout   75s;
        proxy_read_timeout   300s; # <--- Increase this significantly for slow AI tasks
    }
    location = /register {
        proxy_pass http://flask_session_manager/register;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
    }
    location = /admin {
        allow 127.0.0.1; allow ::1; deny all; # IP restriction
        auth_request /auth/verify;             # Session verification
        error_page 401 = @handle_unauthorized;
        error_page 403 = @handle_forbidden;
        error_page 503 = @handle_service_unavailable;
        proxy_pass http://flask_session_manager;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr; # Keep real IP for Flask check
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off;
    }

    # --- *** NEW: Protected Location for the Dashboard *** ---
    location /dashboard {
        # --- Authentication ---
        auth_request /auth/verify;
        auth_request_set $auth_user_role $upstream_http_x_zt_user_role; # Ensure var names match Flask headers
        auth_request_set $auth_access_level $upstream_http_x_zt_access_level;
        auth_request_set $auth_user_id $upstream_http_x_zt_user_id;
        auth_request_set $auth_session_id $upstream_http_x_zt_session_id;

        # --- Error Handling ---
        error_page 401 = @handle_unauthorized;
        error_page 403 = @handle_forbidden;

        # --- Proxy to Dashboard ---
        proxy_pass http://corporate_dashboard; # Route to the dashboard upstream
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Pass validated context if dashboard needs it (even if it checks Redis)
        proxy_set_header X-User-Role $auth_user_role;
        proxy_set_header X-Access-Level $auth_access_level;
        proxy_set_header X-User-Id $auth_user_id;
        proxy_set_header X-Session-Id $auth_session_id;
        proxy_set_header X-ZT-Session-Verified "true"; # Pass verification status
    }
    location /sast {
        # --- Authentication ---
        auth_request /auth/verify;
        auth_request_set $auth_user_role $upstream_http_x_zt_user_role; # Ensure var names match Flask headers
        auth_request_set $auth_access_level $upstream_http_x_zt_access_level;
        auth_request_set $auth_user_id $upstream_http_x_zt_user_id;
        auth_request_set $auth_session_id $upstream_http_x_zt_session_id;

        # --- Error Handling ---
        error_page 401 = @handle_unauthorized;
        error_page 403 = @handle_forbidden;

        # --- Proxy to Dashboard ---
        proxy_pass http://sast_analyzer/; # Route to the dashboard upstream
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Pass validated context if dashboard needs it (even if it checks Redis)
        proxy_set_header X-User-Role $auth_user_role;
        proxy_set_header X-Access-Level $auth_access_level;
        proxy_set_header X-User-Id $auth_user_id;
        proxy_set_header X-Session-Id $auth_session_id;
        proxy_set_header X-ZT-Session-Verified "true"; # Pass verification status
    }
     location /analyze {
        # --- Authentication ---
        auth_request /auth/verify;
        auth_request_set $auth_user_role $upstream_http_x_zt_user_role; # Ensure var names match Flask headers
        auth_request_set $auth_access_level $upstream_http_x_zt_access_level;
        auth_request_set $auth_user_id $upstream_http_x_zt_user_id;
        auth_request_set $auth_session_id $upstream_http_x_zt_session_id;

        # --- Error Handling ---
        error_page 401 = @handle_unauthorized;
        error_page 403 = @handle_forbidden;

        # --- Proxy to Dashboard ---
        proxy_pass http://sast_analyzer/analyze; # Route to the dashboard upstream
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Pass validated context if dashboard needs it (even if it checks Redis)
        proxy_set_header X-User-Role $auth_user_role;
        proxy_set_header X-Access-Level $auth_access_level;
        proxy_set_header X-User-Id $auth_user_id;
        proxy_set_header X-Session-Id $auth_session_id;
        proxy_set_header X-ZT-Session-Verified "true"; # Pass verification status
    }
    location /profile {
        # --- Authentication ---
        auth_request /auth/verify;
        auth_request_set $auth_user_role $upstream_http_x_zt_user_role; # Ensure var names match Flask headers
        auth_request_set $auth_access_level $upstream_http_x_zt_access_level;
        auth_request_set $auth_user_id $upstream_http_x_zt_user_id;
        auth_request_set $auth_session_id $upstream_http_x_zt_session_id;

        # --- Error Handling ---
        error_page 401 = @handle_unauthorized;
        error_page 403 = @handle_forbidden;

        # --- Proxy to Dashboard ---
        proxy_pass http://corporate_dashboard; # Route to the dashboard upstream
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Pass validated context if dashboard needs it (even if it checks Redis)
        proxy_set_header X-User-Role $auth_user_role;
        proxy_set_header X-Access-Level $auth_access_level;
        proxy_set_header X-User-Id $auth_user_id; 
        proxy_set_header X-Session-Id $auth_session_id; 
        proxy_set_header X-ZT-Session-Verified "true"; # Pass verification status
    }
    location /logout {
        # --- Authentication ---
        auth_request /auth/verify;
        auth_request_set $auth_user_role $upstream_http_x_zt_user_role; # Ensure var names match Flask headers
        auth_request_set $auth_access_level $upstream_http_x_zt_access_level;
        auth_request_set $auth_user_id $upstream_http_x_zt_user_id;
        auth_request_set $auth_session_id $upstream_http_x_zt_session_id;

        # --- Error Handling ---
        error_page 401 = @handle_unauthorized;
        error_page 403 = @handle_forbidden;

        # --- Proxy to Dashboard ---
        proxy_pass http://corporate_dashboard; # Route to the dashboard upstream
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Pass validated context if dashboard needs it (even if it checks Redis)
        proxy_set_header X-User-Role $auth_user_role;
        proxy_set_header X-Access-Level $auth_access_level;
        proxy_set_header X-User-Id $auth_user_id;
        proxy_set_header X-Session-Id $auth_session_id;
        proxy_set_header X-ZT-Session-Verified "true"; # Pass verification status
    }



    # --- Handle Unauthorized (remains the same) ---
    # Redirects to the session initiation page
    location @handle_unauthorized {
        # Add Cache-Control headers to prevent caching of the redirect itself
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        expires off;
        # Redirect should ideally trigger re-authentication flow.
        return 302 /session/init; # Redirect to start the process again
    }

     # --- Handle Forbidden (remains the same) ---
    location @handle_forbidden {
        # Return a simple 403 Forbidden page.
        # You might want to serve a custom HTML page here.
        internal; # Prevent direct access to this location
        return 403;
        # Example custom page:
        # error_page 403 /custom_forbidden.html;
        # location = /custom_forbidden.html {
        #   root /path/to/your/error/pages;
        #   internal;
        # }
    }

    # Basic Logging (remains the same)
    access_log /var/log/nginx/zerotrust_proxy_access.log;
    error_log /var/log/nginx/zerotrust_proxy_error.log;
}
